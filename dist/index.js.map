{"version":3,"sources":["../src/actions/transfer.ts","../src/templates/index.ts","../src/providers/wallet.ts","../src/actions/getBalance.ts","../src/actions/portfolio.ts","../src/index.ts"],"sourcesContent":["import { ByteArray, formatEther, parseEther, type Hex } from \"viem\";\nimport {\n    Action,\n    IAgentRuntime,\n    Memory,\n    HandlerCallback,\n    State,\n    composeContext,\n    generateObjectDeprecated,\n    ModelClass,\n    elizaLogger,\n} from \"@elizaos/core\";\n\nimport type { TransferParams, TransferResponse, Transaction } from \"../types\";\nimport { transferTemplate } from \"../templates\";\nimport { initWalletProvider, type WalletProvider, xdcWalletProvider } from \"../providers/wallet\";\n\nexport class TransferAction {\n    constructor(private walletProvider: WalletProvider) {}\n\n    async transfer(params: TransferParams): Promise<Transaction> {\n        const chain = this.walletProvider.getCurrentChain();\n\n        console.log(\n            `Transferring: ${params.amount} tokens to ${params.recipient} on ${chain.name}`\n        );\n\n        // Convert recipient address if it starts with \"xdc\"\n        let toAddress = params.recipient;\n        if (typeof toAddress === 'string' && toAddress.startsWith('xdc')) {\n            toAddress = `0x${toAddress.slice(3)}` as `0x${string}`;\n        }\n\n        // Get the current chain name\n        const chainName = this.walletProvider.getCurrentChain().name.toLowerCase().includes('apothem')\n            ? 'apothem'\n            : 'xdc';\n\n        try {\n            // Parse amount to bigint\n            const valueInWei = parseEther(params.amount || \"0\");\n\n            // Use the wallet provider's transfer method\n            const hash = await this.walletProvider.transfer(\n                chainName,\n                toAddress,\n                valueInWei\n            );\n\n            return {\n                hash,\n                from: this.walletProvider.getAddress(),\n                to: toAddress,\n                value: valueInWei,\n                data: \"0x\" as Hex,\n            };\n        } catch (error) {\n            throw new Error(`Transfer failed: ${error.message}`);\n        }\n    }\n}\n\nexport const transferAction: Action = {\n    name: \"transfer\",\n    description: \"Transfer a token from one address to another on XDC chain\",\n    similes: [\"TRANSFER\", \"SEND_TOKENS\", \"TOKEN_TRANSFER\", \"MOVE_TOKENS\"],\n    validate: async (runtime: IAgentRuntime) => {\n        const privateKey = runtime.getSetting(\"XDC_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: any,\n        callback: HandlerCallback\n    ) => {\n        try {\n            if (!state) {\n                state = (await runtime.composeState(message)) as State;\n            } else {\n                state = await runtime.updateRecentMessageState(state);\n            }\n\n            console.log(\"Transfer xdc_action handler called\");\n\n            state.walletInfo = await xdcWalletProvider.get(\n                runtime,\n                message,\n                state\n            );\n\n            const transferContext = composeContext({\n                state,\n                template: transferTemplate,\n            });\n\n            // Use the deprecated method that doesn't require a schema\n            const content = await generateObjectDeprecated({\n                runtime,\n                context: transferContext,\n                modelClass: ModelClass.LARGE,\n            }) as TransferParams;\n\n            const walletProvider = initWalletProvider(runtime);\n            const action = new TransferAction(walletProvider);\n\n            // Ensure parameters are properly set with defaults\n            const paramOptions: TransferParams = {\n                token: content.token || null,\n                amount: content.amount || \"0\",\n                recipient: content.recipient,\n            };\n\n            const transferResp = await action.transfer(paramOptions);\n\n            const response: TransferResponse = {\n                txHash: transferResp.hash,\n                recipient: transferResp.to as `0x${string}`,\n                amount: formatEther(transferResp.value),\n                token: paramOptions.token || walletProvider.getCurrentChain().nativeCurrency.symbol,\n                data: transferResp.data,\n            };\n\n            callback?.({\n                text: `Successfully transferred ${response.amount} ${response.token} to ${response.recipient}\\nTransaction Hash: ${response.txHash}`,\n                content: response,\n            });\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(error);\n            callback?.({\n                text: `Error transferring tokens: ${error.message}`,\n                content: { error: error.message },\n            });\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Transfer 1 XDC to 0x26939338972fa11eFcA1A438fa5D1Daa54a82Adb\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll help you transfer 1 XDC to 0x26939338972fa11eFcA1A438fa5D1Daa54a82Adb on XDC\",\n                    action: \"TRANSFER\",\n                    content: {\n                        chain: \"xdc\",\n                        token: \"XDC\",\n                        amount: \"1\",\n                        recipient: \"0x26939338972fa11eFcA1A438fa5D1Daa54a82Adb\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Transfer 1 token of 0x1234 to 0x26939338972fa11eFcA1A438fa5D1Daa54a82Adb\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll help you transfer 1 token of 0x1234 to 0x26939338972fa11eFcA1A438fa5D1Daa54a82Adb on XDC\",\n                    action: \"TRANSFER\",\n                    content: {\n                        chain: \"xdc\",\n                        token: \"0x1234\",\n                        amount: \"1\",\n                        recipient: \"0x26939338972fa11eFcA1A438fa5D1Daa54a82Adb\",\n                    },\n                },\n            },\n        ],\n    ],\n};\n","export const transferTemplate = `\n\n{{recentMessages}}\n\nGiven the recent messages, extract the following information about the requested token transfer:\n- Token symbol or contract address(string starting with \"0x\" or \"xdc\"). Optional.\n- Recipient wallet address. Must be a valid Ethereum address starting with \"0x\" or \"xdc\".\n- Amount to transfer. Must be a string representing the amount in ether (only number without coin symbol, e.g., \"0.1\").\n\n\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\n\n\\`\\`\\`json\n{\n    \"token\": string | null,\n    \"amount\": string | null,\n    \"recipient\": string\n}\n\\`\\`\\`\n`;\n\nexport const getBalanceTemplate = `\n\n{{recentMessages}}\n\nGiven the recent messages, extract the following information about the requested balance check:\n- XDC chain to query (options: \"xdc\" for mainnet, \"apothem\" for testnet). If not specified, use the current network.\n- Wallet address to check (an address starting with \"0x\" or \"xdc\"). If not provided, use the agent's own wallet.\n- Token symbol or contract address(string starting with \"0x\" or \"xdc\") to check the balance of. If not provided or is \"XDC\", the native XDC token balance will be checked.\n\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\n\n\\`\\`\\`json\n{\n    \"chain\": string | null,\n    \"address\": string | null,\n    \"token\": string | null\n}\n\\`\\`\\`\n`;\n\nexport const getPortfolioTemplate = `\n\n{{recentMessages}}\n\nGiven the recent messages, extract the following information about the requested portfolio check:\n- XDC chain to query (options: \"xdc\" for mainnet, \"apothem\" for testnet). If not specified, use the current network.\n- Wallet address to check (an address starting with \"0x\" or \"xdc\"). If not provided, use the agent's own wallet.\n\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\n\n\\`\\`\\`json\n{\n    \"chain\": string | null,\n    \"address\": string | null\n}\n\\`\\`\\`\n`;\n","import type {\n    IAgentRuntime,\n    Provider,\n    Memory,\n    State,\n} from \"@elizaos/core\";\nimport type {\n   Address,\n   WalletClient,\n   PublicClient,\n   Chain,\n   HttpTransport,\n   Account,\n   PrivateKeyAccount,\n   Hex,\n} from \"viem\";\nimport {\n   createPublicClient,\n   createWalletClient,\n   formatUnits,\n   http,\n   erc20Abi,\n} from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport * as viemChains from \"viem/chains\";\n\nimport type { SupportedChain } from \"../types\";\n\nexport class WalletProvider {\n   private currentChain: SupportedChain = \"xdc\";\n   chains: Record<string, Chain> = { xdc: viemChains.xdc };\n   account: PrivateKeyAccount;\n\n   constructor(privateKey: `0x${string}`, chains?: Record<string, Chain>) {\n       this.setAccount(privateKey);\n       this.setChains(chains);\n\n       if (chains && Object.keys(chains).length > 0) {\n           this.setCurrentChain(Object.keys(chains)[0] as SupportedChain);\n       }\n   }\n\n   getAccount(): PrivateKeyAccount {\n       return this.account;\n   }\n\n   getAddress(): Address {\n       return this.account.address;\n   }\n\n   getCurrentChain(): Chain {\n       return this.chains[this.currentChain];\n   }\n\n   getPublicClient(\n       chainName: SupportedChain\n   ): PublicClient<HttpTransport, Chain, Account | undefined> {\n       const transport = this.createHttpTransport(chainName);\n\n       const publicClient = createPublicClient({\n           chain: this.chains[chainName],\n           transport,\n       });\n       return publicClient;\n   }\n\n   getWalletClient(chainName: SupportedChain): WalletClient {\n       const transport = this.createHttpTransport(chainName);\n\n       const walletClient = createWalletClient({\n           chain: this.chains[chainName],\n           transport,\n           account: this.account,\n       });\n\n       return walletClient;\n   }\n\n   getChainConfigs(chainName: SupportedChain): Chain {\n       const chain = viemChains[chainName];\n\n       if (!chain?.id) {\n           throw new Error(\"Invalid chain name\");\n       }\n\n       return chain;\n   }\n\n   async formatAddress(address: string): Promise<Address> {\n       if (!address || address.length === 0) {\n           throw new Error(\"Empty address\");\n       }\n\n       if (address.startsWith(\"0x\") && address.length === 42) {\n           return address as Address;\n       }\n\n       if (address.startsWith(\"xdc\")) {\n        // Convert xdc address to 0x format\n        const converted = `0x${address.slice(3)}`;\n        if (converted.length === 42) {\n            return converted as Address;\n        }\n       }\n\n       throw new Error(\"Invalid address\");\n   }\n\n   async checkERC20Allowance(\n       chain: SupportedChain,\n       token: Address,\n       owner: Address,\n       spender: Address,\n   ): Promise<bigint> {\n       const publicClient = this.getPublicClient(chain);\n       return await publicClient.readContract({\n           address: token,\n           abi: erc20Abi,\n           functionName: \"allowance\",\n           args: [owner, spender],\n       });\n   }\n\n   async approveERC20(\n       chain: SupportedChain,\n       token: Address,\n       spender: Address,\n       amount: bigint\n   ): Promise<Hex> {\n       const publicClient = this.getPublicClient(chain);\n       const walletClient = this.getWalletClient(chain);\n       const { request } = await publicClient.simulateContract({\n           account: this.account,\n           address: token,\n           abi: erc20Abi,\n           functionName: \"approve\",\n           args: [spender, amount],\n       });\n\n       return await walletClient.writeContract(request);\n   }\n\n   async transfer(\n       chain: SupportedChain,\n       toAddress: Address,\n       amount: bigint,\n       options?: {\n           gas?: bigint;\n           gasPrice?: bigint;\n           data?: Hex;\n       }\n   ): Promise<Hex> {\n       const walletClient = this.getWalletClient(chain);\n       return await walletClient.sendTransaction({\n           account: this.account,\n           to: toAddress,\n           value: amount,\n           ...options,\n       } as any);\n   }\n\n   async transferERC20(\n       chain: SupportedChain,\n       tokenAddress: Address,\n       toAddress: Address,\n       amount: bigint,\n       options?: {\n           gas?: bigint;\n           gasPrice?: bigint;\n       }\n   ): Promise<Hex> {\n       const publicClient = this.getPublicClient(chain);\n       const walletClient = this.getWalletClient(chain);\n       const { request } = await publicClient.simulateContract({\n           account: this.account,\n           address: tokenAddress as `0x${string}`,\n           abi: erc20Abi,\n           functionName: \"transfer\",\n           args: [toAddress as `0x${string}`, amount],\n           ...options,\n       });\n\n       return await walletClient.writeContract(request);\n   }\n\n   async getBalance(): Promise<string> {\n       const client = this.getPublicClient(this.currentChain);\n       const balance = await client.getBalance({\n           address: this.account.address,\n       });\n       return formatUnits(balance, 18);\n   }\n\n   async getTokenAddress(\n       chainName: SupportedChain,\n       tokenSymbol: string\n   ): Promise<string> {\n       // This is a simplified implementation\n       // In a real scenario, you might want to use an API or a token list\n       if (tokenSymbol.toLowerCase() === 'xdc') {\n           return '0x0000000000000000000000000000000000000000'; // Native token\n       }\n\n       // If it looks like an address, just return it\n       if (tokenSymbol.startsWith('0x') && tokenSymbol.length === 42) {\n           return tokenSymbol;\n       }\n\n       if (tokenSymbol.startsWith('xdc') && tokenSymbol.length === 43) {\n           return `0x${tokenSymbol.slice(3)}`;\n       }\n\n       throw new Error(`Unknown token: ${tokenSymbol}`);\n   }\n\n   addChain(chain: Record<string, Chain>) {\n       this.setChains(chain);\n   }\n\n   switchChain(chainName: SupportedChain, customRpcUrl?: string) {\n       if (!this.chains[chainName]) {\n           const chain = WalletProvider.genChainFromName(\n               chainName,\n               customRpcUrl\n           );\n           this.addChain({ [chainName]: chain });\n       }\n       this.setCurrentChain(chainName);\n   }\n\n   private setAccount = (pk: `0x${string}`) => {\n       this.account = privateKeyToAccount(pk);\n   };\n\n   private setChains = (chains?: Record<string, Chain>) => {\n       if (!chains) {\n           return;\n       }\n       for (const chain of Object.keys(chains)) {\n           this.chains[chain] = chains[chain];\n       }\n   };\n\n   private setCurrentChain = (chain: SupportedChain) => {\n       this.currentChain = chain;\n   };\n\n   private createHttpTransport = (chainName: SupportedChain) => {\n       const chain = this.chains[chainName];\n\n       if (chain.rpcUrls.custom) {\n           return http(chain.rpcUrls.custom.http[0]);\n       }\n       return http(chain.rpcUrls.default.http[0]);\n   };\n\n   static genChainFromName(\n       chainName: string,\n       customRpcUrl?: string | null\n   ): Chain {\n       const baseChain = viemChains[chainName];\n\n       if (!baseChain?.id) {\n           throw new Error(\"Invalid chain name\");\n       }\n\n       const viemChain: Chain = customRpcUrl\n           ? {\n                 ...baseChain,\n                 rpcUrls: {\n                     ...baseChain.rpcUrls,\n                     custom: {\n                         http: [customRpcUrl],\n                     },\n                 },\n             }\n           : baseChain;\n\n       return viemChain;\n   }\n}\n\nconst genChainsFromRuntime = (\n   runtime: IAgentRuntime\n): Record<string, Chain> => {\n   const chains = {};\n\n   // Add XDC mainnet\n   const xdcNetwork = runtime.getSetting(\"XDC_NETWORK\");\n   if (xdcNetwork === \"mainnet\") {\n    chains[\"xdc\"] = WalletProvider.genChainFromName(\"xdc\", viemChains.xdc.rpcUrls.default.http[0]);\n   } else if (xdcNetwork === \"apothem\") {\n    chains[\"apothem\"] = WalletProvider.genChainFromName(\"xdcTestnet\", viemChains.xdcTestnet.rpcUrls.default.http[0]);\n   }\n\n   return chains;\n};\n\nexport const initWalletProvider = (runtime: IAgentRuntime) => {\n   const privateKey = runtime.getSetting(\"XDC_PRIVATE_KEY\");\n   if (!privateKey) {\n       throw new Error(\"XDC_PRIVATE_KEY is missing\");\n   }\n\n   const chains = genChainsFromRuntime(runtime);\n\n   // Create wallet provider\n   const walletProvider = new WalletProvider(privateKey as `0x${string}`, chains);\n\n   // Set initial chain based on network setting\n   const xdcNetwork = runtime.getSetting(\"XDC_NETWORK\");\n   if (xdcNetwork === \"apothem\") {\n       walletProvider.switchChain(\"apothem\");\n   } else {\n       walletProvider.switchChain(\"xdc\");\n   }\n\n   return walletProvider;\n};\n\nexport const xdcWalletProvider: Provider = {\n   async get(\n       runtime: IAgentRuntime,\n       _message: Memory,\n       _state?: State\n   ): Promise<string | null> {\n       try {\n           const walletProvider = initWalletProvider(runtime);\n           const address = walletProvider.getAddress();\n           const balance = await walletProvider.getBalance();\n           const chain = walletProvider.getCurrentChain();\n           const networkName = chain.name.toLowerCase().includes('apothem') ? 'Apothem Testnet' : 'XDC Mainnet';\n\n           return `XDC Network (${networkName}) Wallet Address: ${address}\\nBalance: ${balance} ${chain.nativeCurrency.symbol}\\nChain ID: ${chain.id}, Name: ${chain.name}`;\n       } catch (error) {\n           console.error(\"Error in XDC chain wallet provider:\", error);\n           return null;\n       }\n   },\n};","import {\n    composeContext,\n    elizaLogger,\n    generateObjectDeprecated,\n    type HandlerCallback,\n    ModelClass,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    Action,\n} from \"@elizaos/core\";\nimport {\n    xdcWalletProvider,\n    initWalletProvider,\n    type WalletProvider,\n} from \"../providers/wallet\";\nimport { getBalanceTemplate } from \"../templates\";\nimport type {\n    GetBalanceParams,\n    GetBalanceResponse,\n    SupportedChain,\n} from \"../types\";\nimport { type Address, erc20Abi, formatEther, formatUnits } from \"viem\";\n\nexport { getBalanceTemplate };\n\nexport class GetBalanceAction {\n    constructor(private walletProvider: WalletProvider) {}\n\n    async getBalance(params: GetBalanceParams): Promise<GetBalanceResponse> {\n        elizaLogger.debug(\"Get balance params:\", params);\n        await this.validateAndNormalizeParams(params);\n        elizaLogger.debug(\"Normalized get balance params:\", params);\n\n        const { chain, address, token } = params;\n        if (!address) {\n            throw new Error(\"Address is required for getting balance\");\n        }\n\n        if (!chain) {\n            throw new Error(\"Chain is required for getting balance\");\n        }\n\n        this.walletProvider.switchChain(chain);\n        const nativeSymbol =\n            this.walletProvider.getCurrentChain().nativeCurrency.symbol;\n\n        let queryNativeToken = false;\n        if (\n            !token ||\n            token === \"\" ||\n            token.toLowerCase() === \"xdc\"\n        ) {\n            queryNativeToken = true;\n        }\n\n        const resp: GetBalanceResponse = {\n            chain,\n            address,\n        };\n\n        // If ERC20 token is requested\n        if (!queryNativeToken) {\n            let amount: string;\n            if (token.startsWith(\"0x\") || token.startsWith(\"xdc\")) {\n                // Convert xdc address format to 0x format if needed\n                let tokenAddress = token;\n                if (token.startsWith(\"xdc\")) {\n                    tokenAddress = `0x${token.slice(3)}`;\n                }\n\n                amount = await this.getERC20TokenBalance(\n                    chain,\n                    address,\n                    tokenAddress as `0x${string}`\n                );\n            } else {\n                throw new Error(\n                    \"Only token addresses starting with 0x or xdc are supported. For native XDC token, use 'XDC' as token symbol.\"\n                );\n            }\n\n            resp.balance = { token, amount };\n        } else {\n            // If native token is requested\n            const nativeBalanceWei = await this.walletProvider\n                .getPublicClient(chain)\n                .getBalance({ address });\n            resp.balance = {\n                token: nativeSymbol,\n                amount: formatEther(nativeBalanceWei),\n            };\n        }\n\n        return resp;\n    }\n\n    async getERC20TokenBalance(\n        chain: SupportedChain,\n        address: Address,\n        tokenAddress: Address\n    ): Promise<string> {\n        const publicClient = this.walletProvider.getPublicClient(chain);\n\n        const balance = await publicClient.readContract({\n            address: tokenAddress,\n            abi: erc20Abi,\n            functionName: \"balanceOf\",\n            args: [address],\n        });\n\n        const decimals = await publicClient.readContract({\n            address: tokenAddress,\n            abi: erc20Abi,\n            functionName: \"decimals\",\n        });\n\n        return formatUnits(balance, decimals);\n    }\n\n    async validateAndNormalizeParams(params: GetBalanceParams): Promise<void> {\n        // Set default chain if not provided\n        if (!params.chain) {\n            params.chain = this.walletProvider.getCurrentChain().name.toLowerCase().includes('apothem')\n                ? 'apothem'\n                : 'xdc';\n        }\n\n        // Set default address to wallet address if not provided\n        if (!params.address) {\n            params.address = this.walletProvider.getAddress();\n        } else if (typeof params.address === 'string') {\n            // Convert xdc address format to 0x format if needed\n            if (params.address.startsWith('xdc')) {\n                params.address = `0x${params.address.slice(3)}` as Address;\n            }\n        }\n    }\n}\n\nexport const getBalanceAction: Action = {\n    name: \"getBalance\",\n    description: \"Get balance of XDC or tokens on the XDC network\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.log(\"Starting getBalance action for XDC...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        // Get wallet info\n        currentState.walletInfo = await xdcWalletProvider.get(\n            runtime,\n            message,\n            currentState\n        );\n\n        // Compose balance context\n        const getBalanceContext = composeContext({\n            state: currentState,\n            template: getBalanceTemplate,\n        });\n\n        const content = await generateObjectDeprecated({\n            runtime,\n            context: getBalanceContext,\n            modelClass: ModelClass.LARGE,\n        }) as GetBalanceParams;\n\n        const walletProvider = initWalletProvider(runtime);\n        const action = new GetBalanceAction(walletProvider);\n\n        const getBalanceOptions: GetBalanceParams = {\n            chain: content.chain,\n            address: content.address,\n            token: content.token,\n        };\n\n        try {\n            const getBalanceResp = await action.getBalance(getBalanceOptions);\n            if (callback) {\n                let text = `No balance found for ${getBalanceResp.address} on ${getBalanceResp.chain}`;\n                if (getBalanceResp.balance) {\n                    text = `Balance of ${getBalanceResp.address} on ${getBalanceResp.chain}:\\n${\n                        getBalanceResp.balance.token\n                    }: ${getBalanceResp.balance.amount}`;\n                }\n                callback({\n                    text,\n                    content: { ...getBalanceResp },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error during get balance:\", error.message);\n            callback?.({\n                text: `Get balance failed: ${error.message}`,\n                content: { error: error.message },\n            });\n            return false;\n        }\n    },\n    validate: async (runtime: IAgentRuntime) => {\n        const privateKey = runtime.getSetting(\"XDC_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Check my XDC balance\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll help you check your XDC balance\",\n                    action: \"GET_BALANCE\",\n                    content: {\n                        chain: \"xdc\",\n                        address: \"{{walletAddress}}\",\n                        token: \"XDC\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Check my balance of token 0x1234 on XDC\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll help you check your balance of token 0x1234 on XDC\",\n                    action: \"GET_BALANCE\",\n                    content: {\n                        chain: \"xdc\",\n                        address: \"{{walletAddress}}\",\n                        token: \"0x1234\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's the XDC balance of xdc71C7656EC7ab88b098defB751B7401B5f6d8976F?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the XDC balance of that address\",\n                    action: \"GET_BALANCE\",\n                    content: {\n                        chain: \"xdc\",\n                        address: \"xdc71C7656EC7ab88b098defB751B7401B5f6d8976F\",\n                        token: \"XDC\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Check my wallet balance on Apothem testnet\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll help you check your wallet balance on Apothem testnet\",\n                    action: \"GET_BALANCE\",\n                    content: {\n                        chain: \"apothem\",\n                        address: \"{{walletAddress}}\",\n                        token: \"XDC\",\n                    },\n                },\n            },\n        ],\n    ],\n    similes: [\"GET_BALANCE\", \"CHECK_BALANCE\", \"SHOW_BALANCE\"],\n};\n","import {\n    composeContext,\n    elizaLogger,\n    generateObjectDeprecated,\n    type HandlerCallback,\n    ModelClass,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    Action,\n} from \"@elizaos/core\";\nimport {\n    xdcWalletProvider,\n    initWalletProvider,\n    type WalletProvider,\n} from \"../providers/wallet\";\nimport { getPortfolioTemplate } from \"../templates\";\nimport type {\n    GetPortfolioParams,\n    GetPortfolioResponse,\n    Portfolio,\n    SupportedChain,\n    TokenBalance,\n} from \"../types\";\nimport { type Address, erc20Abi, formatEther, formatUnits } from \"viem\";\nimport NodeCache from \"node-cache\";\n\nexport { getPortfolioTemplate };\n\n// Common token addresses on XDC network - add more as needed\nconst KNOWN_TOKENS: Record<string, { address: string; symbol: string }[]> = {\n    xdc: [\n        { address: \"0x0000000000000000000000000000000000000000\", symbol: \"XDC\" }, // Native token\n        // Add other main XDC tokens here\n    ],\n    apothem: [\n        { address: \"0x0000000000000000000000000000000000000000\", symbol: \"XDC\" }, // Native token\n        // Add other Apothem tokens here\n    ],\n};\n\nexport class PortfolioAction {\n    private cache: NodeCache;\n    private readonly CACHE_EXPIRY_SEC = 60; // 1 minute cache\n\n    constructor(private walletProvider: WalletProvider) {\n        this.cache = new NodeCache({ stdTTL: this.CACHE_EXPIRY_SEC });\n    }\n\n    async getPortfolio(params: GetPortfolioParams): Promise<Portfolio> {\n        elizaLogger.debug(\"Get portfolio params:\", params);\n        await this.validateAndNormalizeParams(params);\n        elizaLogger.debug(\"Normalized portfolio params:\", params);\n\n        const { chain, address } = params;\n        if (!address) {\n            throw new Error(\"Address is required for getting portfolio\");\n        }\n\n        if (!chain) {\n            throw new Error(\"Chain is required for getting portfolio\");\n        }\n\n        // Create portfolio response structure\n        const portfolio: Portfolio = {\n            chain,\n            address,\n            balances: [],\n        };\n\n        // Check cached result first\n        const cacheKey = `portfolio_${chain}_${address}`;\n        const cachedResult = this.cache.get<Portfolio>(cacheKey);\n        if (cachedResult) {\n            elizaLogger.debug(\"Returning cached portfolio result\");\n            return cachedResult;\n        }\n\n        try {\n            // Set the chain\n            this.walletProvider.switchChain(chain);\n\n            // Get native token balance\n            const nativeSymbol = this.walletProvider.getCurrentChain().nativeCurrency.symbol;\n            const nativeBalanceWei = await this.walletProvider\n                .getPublicClient(chain)\n                .getBalance({ address });\n\n            portfolio.balances.push({\n                token: \"0x0000000000000000000000000000000000000000\",\n                symbol: nativeSymbol,\n                amount: formatEther(nativeBalanceWei),\n            });\n\n            // Get balances for known tokens on this chain\n            if (KNOWN_TOKENS[chain]) {\n                for (const token of KNOWN_TOKENS[chain]) {\n                    if (token.address !== \"0x0000000000000000000000000000000000000000\") { // Skip native token\n                        try {\n                            const balance = await this.getERC20TokenBalance(\n                                chain,\n                                address,\n                                token.address as `0x${string}`\n                            );\n\n                            // Only add tokens with non-zero balance\n                            if (balance !== \"0\") {\n                                portfolio.balances.push({\n                                    token: token.address,\n                                    symbol: token.symbol,\n                                    amount: balance,\n                                });\n                            }\n                        } catch (error) {\n                            elizaLogger.error(`Error fetching balance for token ${token.symbol}:`, error.message);\n                            // Continue with other tokens\n                        }\n                    }\n                }\n            }\n\n            // Cache the result\n            this.cache.set(cacheKey, portfolio);\n\n            return portfolio;\n        } catch (error) {\n            throw new Error(`Failed to get portfolio: ${error.message}`);\n        }\n    }\n\n    async getERC20TokenBalance(\n        chain: SupportedChain,\n        address: Address,\n        tokenAddress: Address\n    ): Promise<string> {\n        const publicClient = this.walletProvider.getPublicClient(chain);\n\n        const balance = await publicClient.readContract({\n            address: tokenAddress,\n            abi: erc20Abi,\n            functionName: \"balanceOf\",\n            args: [address],\n        });\n\n        const decimals = await publicClient.readContract({\n            address: tokenAddress,\n            abi: erc20Abi,\n            functionName: \"decimals\",\n        });\n\n        return formatUnits(balance, decimals);\n    }\n\n    async validateAndNormalizeParams(params: GetPortfolioParams): Promise<void> {\n        // Set default chain if not provided\n        if (!params.chain) {\n            params.chain = this.walletProvider.getCurrentChain().name.toLowerCase().includes('apothem')\n                ? 'apothem'\n                : 'xdc';\n        }\n\n        // Set default address to wallet address if not provided\n        if (!params.address) {\n            params.address = this.walletProvider.getAddress();\n        } else if (typeof params.address === 'string') {\n            // Convert xdc address format to 0x format if needed\n            if (params.address.startsWith('xdc')) {\n                params.address = `0x${params.address.slice(3)}` as Address;\n            }\n        }\n    }\n\n    formatPortfolioOutput(portfolio: Portfolio): string {\n        let output = `Portfolio for ${portfolio.address} on ${portfolio.chain} network:\\n\\n`;\n\n        if (portfolio.balances.length === 0) {\n            return output + \"No tokens found in this wallet.\";\n        }\n\n        portfolio.balances.forEach((balance) => {\n            const symbol = balance.symbol || balance.token;\n            output += `${symbol}: ${balance.amount}\\n`;\n        });\n\n        return output;\n    }\n}\n\nexport const portfolioAction: Action = {\n    name: \"getPortfolio\",\n    description: \"Get portfolio of XDC and tokens on the XDC network\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback\n    ) => {\n        elizaLogger.log(\"Starting getPortfolio action for XDC...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        // Get wallet info\n        currentState.walletInfo = await xdcWalletProvider.get(\n            runtime,\n            message,\n            currentState\n        );\n\n        // Compose portfolio context\n        const getPortfolioContext = composeContext({\n            state: currentState,\n            template: getPortfolioTemplate,\n        });\n\n        const content = await generateObjectDeprecated({\n            runtime,\n            context: getPortfolioContext,\n            modelClass: ModelClass.LARGE,\n        }) as GetPortfolioParams;\n\n        const walletProvider = initWalletProvider(runtime);\n        const action = new PortfolioAction(walletProvider);\n\n        const getPortfolioOptions: GetPortfolioParams = {\n            chain: content.chain,\n            address: content.address,\n        };\n\n        try {\n            const portfolio = await action.getPortfolio(getPortfolioOptions);\n\n            if (callback) {\n                const formattedOutput = action.formatPortfolioOutput(portfolio);\n\n                callback({\n                    text: formattedOutput,\n                    content: { portfolio } as GetPortfolioResponse,\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error during portfolio check:\", error.message);\n            callback?.({\n                text: `Get portfolio failed: ${error.message}`,\n                content: { error: error.message },\n            });\n            return false;\n        }\n    },\n    validate: async (runtime: IAgentRuntime) => {\n        const privateKey = runtime.getSetting(\"XDC_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show my XDC portfolio\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll help you check your portfolio on XDC network\",\n                    action: \"GET_PORTFOLIO\",\n                    content: {\n                        chain: \"xdc\",\n                        address: \"{{walletAddress}}\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's in my wallet on XDC?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll show you the tokens in your wallet on XDC\",\n                    action: \"GET_PORTFOLIO\",\n                    content: {\n                        chain: \"xdc\",\n                        address: \"{{walletAddress}}\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What tokens does xdc71C7656EC7ab88b098defB751B7401B5f6d8976F have?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the tokens this address holds on XDC\",\n                    action: \"GET_PORTFOLIO\",\n                    content: {\n                        chain: \"xdc\",\n                        address: \"xdc71C7656EC7ab88b098defB751B7401B5f6d8976F\",\n                    },\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show my Apothem testnet portfolio\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll help you check your portfolio on Apothem testnet\",\n                    action: \"GET_PORTFOLIO\",\n                    content: {\n                        chain: \"apothem\",\n                        address: \"{{walletAddress}}\",\n                    },\n                },\n            },\n        ],\n    ],\n    similes: [\"GET_PORTFOLIO\", \"CHECK_PORTFOLIO\", \"SHOW_PORTFOLIO\", \"LIST_TOKENS\", \"MY_TOKENS\"],\n};\n","import type { Plugin } from \"@elizaos/core\";\nimport { transferAction } from \"./actions/transfer\";\nimport { getBalanceAction } from \"./actions/getBalance\";\nimport { portfolioAction } from \"./actions/portfolio\";\nconsole.log(\"XDC IS BEING INITIALIZED\")\n\nexport const xdcPlugin: Plugin = {\n    name: \"xdc\",\n    description: \"XDC Plugin for Eliza\",\n    actions: [\n        transferAction,\n        getBalanceAction,\n        portfolioAction\n    ],\n    evaluators: [],\n    providers: [],\n};\n\nexport default xdcPlugin;"],"mappings":"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","names":["composeContext","elizaLogger","generateObjectDeprecated","ModelClass","erc20Abi","formatEther","formatUnits","elizaLogger","formatEther","erc20Abi","formatUnits","composeContext","generateObjectDeprecated","ModelClass","composeContext","elizaLogger","generateObjectDeprecated","ModelClass","erc20Abi","formatEther","formatUnits","elizaLogger","formatEther","erc20Abi","formatUnits","composeContext","generateObjectDeprecated","ModelClass"]}